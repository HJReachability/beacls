
#include <levelset/InitialConditions/BasicShapes/ShapeRectangleByCenter.hpp>
#include <levelset/InitialConditions/BasicShapes/ShapeRectangleByCorner.hpp>
#include <levelset/Grids/HJI_Grid.hpp>
#include "ShapeRectangleByCenter_impl.hpp"

ShapeRectangleByCenter_impl::ShapeRectangleByCenter_impl(
	const beacls::FloatVec& center,
	const beacls::FloatVec& widths) : 
	center(center),
	widths(widths)
	{
}
ShapeRectangleByCenter_impl::~ShapeRectangleByCenter_impl() {

}
bool ShapeRectangleByCenter_impl::execute(const HJI_Grid *grid, beacls::FloatVec& data) const {
	if (!grid) return false;
	/*
	* get differential value from nearest data
	* from upper or lower bound to itself
	*/
	//---------------------------------------------------------------------------
	// Implicit surface function calculation.
	//   This is basically the intersection (by max operator) of halfspaces.
	//   While each halfspace is generated by a signed distance function,
	//   the resulting intersection is not quite a signed distance function.
	beacls::IntegerVec N = grid->get_Ns();

	size_t num_of_dimensions = grid->get_num_of_dimensions();

	beacls::FloatVec lower(num_of_dimensions, 0);
	beacls::FloatVec upper(num_of_dimensions, 0);
	std::transform(center.cbegin(), center.cend(), widths.cbegin(), lower.begin(), ([](const auto &c, const auto &w) {
		return c - 0.5 * w;
	}));
	std::transform(center.cbegin(), center.cend(), widths.cbegin(), upper.begin(), ([](const auto &c, const auto &w) {
		return c + 0.5 * w;
	}));

	ShapeRectangleByCorner chapeRectangleByCorner(lower, upper);
	return chapeRectangleByCorner.execute(grid, data);
}


ShapeRectangleByCenter::ShapeRectangleByCenter(
	const beacls::FloatVec& center,
	const beacls::FloatVec& widths) {
	pimpl = new ShapeRectangleByCenter_impl(center, widths);
}
ShapeRectangleByCenter::~ShapeRectangleByCenter() {
	if (pimpl) delete pimpl;
}
bool ShapeRectangleByCenter::execute(
	const HJI_Grid *grid, beacls::FloatVec& data
	) const {
	if (pimpl) return pimpl->execute(grid, data);
	else return false;
}
ShapeRectangleByCenter::ShapeRectangleByCenter(const ShapeRectangleByCenter& rhs) :
	pimpl(rhs.pimpl->clone())
{
};

ShapeRectangleByCenter* ShapeRectangleByCenter::clone() const {
	return new ShapeRectangleByCenter(*this);
};
