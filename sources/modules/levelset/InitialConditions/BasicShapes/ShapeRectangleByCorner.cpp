#include <levelset/InitialConditions/BasicShapes/ShapeRectangleByCorner.hpp>
#include <levelset/Grids/HJI_Grid.hpp>
#include "ShapeRectangleByCorner_impl.hpp"
#include <macro.hpp>
using namespace levelset;

ShapeRectangleByCorner_impl::ShapeRectangleByCorner_impl(
	const beacls::FloatVec& lower,
	const beacls::FloatVec& upper) : 
	lower(lower),
	upper(upper)
	{
}
ShapeRectangleByCorner_impl::~ShapeRectangleByCorner_impl() {

}
bool ShapeRectangleByCorner_impl::execute(const HJI_Grid *grid, beacls::FloatVec& data) const {
	if (!grid) return false;
	/*
	* get differential value from nearest data
	* from upper or lower bound to itself
	*/
	//---------------------------------------------------------------------------
	// Implicit surface function calculation.
	//   This is basically the intersection (by max operator) of halfspaces.
	//   While each halfspace is generated by a signed distance function,
	//   the resulting intersection is not quite a signed distance function.
	beacls::IntegerVec N = grid->get_Ns();

	size_t num_of_dimensions = grid->get_num_of_dimensions();
	const size_t num_of_elements = grid->get_sum_of_elems();
	data.resize(num_of_elements);
#if 0
	const std::vector<beacls::FloatVec > &xss = grid->get_xss();
	for (size_t i = 0; i<num_of_elements; ++i) {
		FLOAT_TYPE len_upper2data = xss[0][i] - upper[0];
		FLOAT_TYPE len_lower2data = lower[0] - xss[0][i];
		data[i] = HjiMax(len_upper2data, len_lower2data);
	}
	for (size_t i = 0; i<num_of_elements; ++i) {
		for (size_t dimension = 1; dimension<num_of_dimensions; ++dimension) {
			FLOAT_TYPE xs = xss[dimension][i];
			FLOAT_TYPE len_upper2data = xs - upper[dimension];
			FLOAT_TYPE len_lower2data = lower[dimension] - xs;
			data[i] = HjiMax(data[i], len_upper2data);
			data[i] = HjiMax(data[i], len_lower2data);
		}
	}
#else
#if defined(ADHOCK_XS)
	const FLOAT_TYPE inf = -std::numeric_limits<FLOAT_TYPE>::infinity();
	data.assign(num_of_elements, inf);
	for (size_t dimension = 0; dimension < num_of_dimensions; ++dimension) {
		const beacls::FloatVec& vs = grid->get_vs(dimension);
		size_t inner_dimensions_loop_size = grid->get_inner_dimensions_loop_size(dimension);
		size_t outer_dimensions_loop_size = grid->get_outer_dimensions_loop_size(dimension);
		size_t target_dimension_loop_size = grid->get_target_dimension_loop_size(dimension);
		const FLOAT_TYPE upper_d = upper[dimension];
		const FLOAT_TYPE lower_d = lower[dimension];
		for (size_t outer_dimensions_loop_index = 0; outer_dimensions_loop_index < outer_dimensions_loop_size; ++outer_dimensions_loop_index) {
			const size_t outer_dimensions_loop_offset = outer_dimensions_loop_index * inner_dimensions_loop_size * target_dimension_loop_size;
			for (size_t v_index = 0; v_index < vs.size(); ++v_index) {
				const FLOAT_TYPE v = vs[v_index];
				const size_t offset = v_index * inner_dimensions_loop_size + outer_dimensions_loop_offset;
				const FLOAT_TYPE len_upper2data = v - upper_d;
				const FLOAT_TYPE len_lower2data = lower_d - v;
				std::for_each(data.begin() + offset, data.begin() + offset + inner_dimensions_loop_size, ([len_upper2data, len_lower2data](auto &rhs) {
					rhs = HjiMax(rhs, len_upper2data);
					rhs = HjiMax(rhs, len_lower2data);
				}));
			}
		}
	}
#else
	std::vector<beacls::UVec> x_uvecs;
	grid->get_xss(x_uvecs);
	std::vector<const FLOAT_TYPE*> x_ptrs(num_of_dimensions);
	std::transform(x_uvecs.cbegin(), x_uvecs.cend(), x_ptrs.begin(), [](const auto rhs) {
		return beacls::UVec_<const FLOAT_TYPE>(rhs).ptr();
	});
	for (size_t i = 0; i<num_of_elements; ++i) {
		FLOAT_TYPE len_upper2data0 = x_ptrs[0][i] - upper[0];
		FLOAT_TYPE len_lower2data0 = lower[0] - x_ptrs[0][i];
		FLOAT_TYPE val = HjiMax(len_upper2data0, len_lower2data0);
		for (size_t dimension = 1; dimension<num_of_dimensions; ++dimension) {
			FLOAT_TYPE xs = x_ptrs[dimension][i];
			FLOAT_TYPE len_upper2data = xs - upper[dimension];
			FLOAT_TYPE len_lower2data = lower[dimension] - xs;
			val = HjiMax(val, len_upper2data);
			val = HjiMax(val, len_lower2data);
		}
		data[i] = val;
	}
#endif
#endif
	return true;
}


ShapeRectangleByCorner::ShapeRectangleByCorner(
	const beacls::FloatVec& lower,
	const beacls::FloatVec& upper) {
	pimpl = new ShapeRectangleByCorner_impl(lower,upper);
}
ShapeRectangleByCorner::~ShapeRectangleByCorner() {
	if (pimpl) delete pimpl;
}
bool ShapeRectangleByCorner::execute(
	const HJI_Grid *grid, beacls::FloatVec& data
	) const {
	if (pimpl) return pimpl->execute(grid, data);
	else return false;
}
ShapeRectangleByCorner::ShapeRectangleByCorner(const ShapeRectangleByCorner& rhs) :
	pimpl(rhs.pimpl->clone())
{
};

ShapeRectangleByCorner* ShapeRectangleByCorner::clone() const {
	return new ShapeRectangleByCorner(*this);
};
