#include <levelset/InitialConditions/BasicShapes/ShapeRectangleByCorner.hpp>
#include <levelset/Grids/HJI_Grid.hpp>
#include "ShapeRectangleByCorner_impl.hpp"
#include <macro.hpp>
using namespace levelset;

ShapeRectangleByCorner_impl::ShapeRectangleByCorner_impl(
	const beacls::FloatVec& lower,
	const beacls::FloatVec& upper) : 
	lower(lower),
	upper(upper)
	{
}
ShapeRectangleByCorner_impl::~ShapeRectangleByCorner_impl() {

}
bool ShapeRectangleByCorner_impl::execute(const HJI_Grid *grid, beacls::FloatVec& data) const {
	if (!grid) return false;
	/*
	* get differential value from nearest data
	* from upper or lower bound to itself
	*/
	//---------------------------------------------------------------------------
	// Implicit surface function calculation.
	//   This is basically the intersection (by max operator) of halfspaces.
	//   While each halfspace is generated by a signed distance function,
	//   the resulting intersection is not quite a signed distance function.
	beacls::IntegerVec N = grid->get_Ns();

	size_t num_of_dimensions = grid->get_num_of_dimensions();
	const size_t num_of_elements = grid->get_sum_of_elems();
	data.resize(num_of_elements);
	const std::vector<beacls::FloatVec > &xss = grid->get_xss();
	for (size_t i = 0; i<num_of_elements; ++i) {
		FLOAT_TYPE len_upper2data = xss[0][i] - upper[0];
		FLOAT_TYPE len_lower2data = lower[0] - xss[0][i];
		data[i] = HjiMax(len_upper2data, len_lower2data);
	}
	for (size_t i = 0; i<num_of_elements; ++i) {
		for (size_t dimension = 1; dimension<num_of_dimensions; ++dimension) {
			FLOAT_TYPE xs = xss[dimension][i];
			FLOAT_TYPE len_upper2data = xs - upper[dimension];
			FLOAT_TYPE len_lower2data = lower[dimension] - xs;
			data[i] = HjiMax(data[i], len_upper2data);
			data[i] = HjiMax(data[i], len_lower2data);
		}
	}
	return true;
}


ShapeRectangleByCorner::ShapeRectangleByCorner(
	const beacls::FloatVec& lower,
	const beacls::FloatVec& upper) {
	pimpl = new ShapeRectangleByCorner_impl(lower,upper);
}
ShapeRectangleByCorner::~ShapeRectangleByCorner() {
	if (pimpl) delete pimpl;
}
bool ShapeRectangleByCorner::execute(
	const HJI_Grid *grid, beacls::FloatVec& data
	) const {
	if (pimpl) return pimpl->execute(grid, data);
	else return false;
}
ShapeRectangleByCorner::ShapeRectangleByCorner(const ShapeRectangleByCorner& rhs) :
	pimpl(rhs.pimpl->clone())
{
};

ShapeRectangleByCorner* ShapeRectangleByCorner::clone() const {
	return new ShapeRectangleByCorner(*this);
};
